-*- text -*-

* Feedback window
  
  We need to tell the user the new geometry somehow. Is this what I
  want?

  The feedback window can also show what workspace we just changed to.

  Can we cooperate with a stand-alone program? Write our status to a
  root hint than can be picked up by another program?

* Changing focus from keyboard

  Save the subwindows of the root window and focus each when pressing
  modkey + user_key_change. First option always last focused window.

  Partly done. I have added a linked list of all windows and can walk
  around them in a simple window ring.

  We need to re-arrange the list so the last focused window gets to be
  the next in ring. Perhaps simply move the focused window to head of
  list after finishing focusing? How do we know when we're finished
  and have the focus we want? Both Tab and Mod2 are released. Use a
  mode?

  How do we re-establish stack order after moving around windows to
  focus on?

* Virtual screens/workspaces

  Partially done. Still needed:

  - A window might be on one, *several* or all virtual screens. 

    We already have a way of fixing a window on all screens (Mod2-f),
    but we need a way of saying "stick on this workspace". Perhaps
    something like Mod2-a <n>, where <n> is 1--9 for virtual screens.
    Better ways? Note that this seems to be mildly incompatible with
    the EWMH _NET_WM_DESKTOP hint we're currently using: We will only
    be able to save one of the desktops used.

* Use window resizing hints.

  Done, but needs looking over. 

  Needs to use the data in the window list instead of asking the
  server every time. This means we have to update the window list
  data, however.

  When maximizing windows, we need to consider the window resizing
  hints. Either that or special treatment when starting to resize a
  maximized window. As it is, we can get off by a few pixels when
  resizing a maximized window and leave trails...

  Special treatment when someone resizes a fully maximed window...
  Should it be possible at all? If so, we need to set new border width
  when they do it.
  
  Possibly set and read hint about maximized state.

* Snap to border and screen edge, which favours the edge.

* Figure out why unclutter doesn't work in default mode

  It creates a subwindow and sends a synthetic enter notify back to
  the client.

  unclutter -grab works, though, but that mucks with slock. It makes
  slock unlock the screen after ~20 seconds!

* Flag to disable dontmoveoff?

* RandR/Xinerama

  Get physical screen characteristics for every screen. Maximize, move
  to corners should respect the screen it's on. We want a set of
  workspaces for every physical screen as well.

  xcb_randr_screen_size_t

  xcb_randr_screen_size_iterator_t

  xcb_randr_get_screen_info_reply_t

  xcb_randr_set_screen_size_request_t

  How do we handle window moves from one screen to another. Should we
  snap to the physical screen's edge and then allow move to continue?

* Key to move pointer to another physical screen.

* Use xcb-event's event handlers?

* Configurable keys.

* Configuration file.

* Start configurable programs when clicking on root window.

* Handle Urgency hint

  Some windows might need attention and marks this with an urgency
  hint (for instance, urxvt can generate such a hint when receiving
  the BEL character). Do we want to handle it? How do we tell the
  user? Can this be done with some stand-alone program instead?
