-*- text -*-

* Grab specific keys 

  Current code grabs modifier keys and any other keypress. We need to
  specifically grab the keycodes we need. xbindkeys and possibly other
  programs don't work.

  Partially done. Now grabs all our keys unshifted as well as shifted.
  Needs a way to tell in config.h what extra modifier is used.

* MappingNotify

  Need to handle any changes of the keyboard mapping.

* Feedback window
  
  We need to tell the user the new geometry somehow. Is this what I
  want?

  The feedback window can also show what workspace we just changed to.

  Can we cooperate with a stand-alone program? Write our status to a
  root hint than can be picked up by another program?

* Changing focus from keyboard

  Save the subwindows of the root window and focus each when pressing
  modkey + user_key_change. First option always last focused window.

  I would like it to work like this: modkey-Tab-Tab-Tab... Release
  modkey to focus on a window *and* to remember the window where we
  started. The window we remember would be moved to the next position
  in the window list.

  This will also need to work if the change focus with the mouse.

  A single modkey-Tab would then get the focus to end up in the window where
  we started tabbing or where we last had our focus if changing with
  the mouse.

  This is done, but in a bit ugly way. I have bound Alt_L explicitly
  and looking for key release events.

  It is possible to ask for what keys give XCB_MOD_MASK_4 or whatever
  MODKEY is.

    GetModifierMapping

    This request returns the keycodes of the keys being used as
    modifiers. The number of keycodes in the list is
    8*keycodes-per-modifier. The keycodes are divided into eight sets,
    with each set containing keycodes-per-modifier elements. The sets
    are assigned to the modifiers Shift, Lock, Control, Mod1, Mod2,
    Mod3, Mod4, and Mod5, in order. The keycodes-per-modifier value is
    chosen arbitrarily by the server; zeroes are used to fill in
    unused elements within each set. If only zero values are given in
    a set, the use of the corresponding modifier has been disabled.
    The order of keycodes within each set is chosen arbitrarily by the
    server.

    xcb_get_modifier_mapping()

    xcb_get_modifier_mapping_unchecked()

    xcb_keycode_t * xcb_get_modifier_mapping_keycodes()

    xcb_keycode_t *
    xcb_get_modifier_mapping_keycodes (const xcb_get_modifier_mapping_reply_t *R  /**< */);

    xcb_get_modifier_mapping_keycodes_length (const xcb_get_modifier_mapping_reply_t *R  /**< */);

  How do we re-establish stack order after moving around windows to
  focus on? Do we want to?

* Virtual screens/workspaces

  Partially done. Still needed:

  - A window might be on one, *several* or all virtual screens. 

    We already have a way of fixing a window on all screens (Mod2-f),
    but we need a way of saying "stick on this workspace". Perhaps
    something like Mod2-a <n>, where <n> is 1--9 for virtual screens.
    Better ways? Note that this seems to be mildly incompatible with
    the EWMH _NET_WM_DESKTOP hint we're currently using: We will only
    be able to save one of the desktops used.

* Hide windows

  Instead of iconifying, hide them Ã  la 9wm. Even if we use a key to
  hide them, this probably means we have to have a menu to get them
  back.

* Menu

  We might need a menu for hidden windows (see above). Since I'm
  probably implementing menu windows anyway, perhaps I should add a
  menu with basic window functions, like 9wm and twm. This way, one
  might use the window manager without keyboard, if necessary. Not
  much work if I have to do the menu anyway... But also chords?

* Chords

  Maybe have mouse button chords to do move and resize? Configurable
  if on or off?

  Idea from Christian Neukirchen.

* Snap to border and screen edge, which favours the edge.

* Gaps on borders for docks, status windows et cetera.

  Keep space reserved for Conky, dzen2 et cetera.
  
  Also respect EWMH hints _NET_WM_TYPE_DOCK and _NET_WM_TYPE_DESKTOP.

* Flag to disable dontmoveoff?

* RandR/Xinerama

  Get physical screen characteristics for every screen. Maximize, move
  to corners should respect the screen it's on. We want a set of
  workspaces for every physical screen as well.

  xcb_randr_screen_size_t

  xcb_randr_screen_size_iterator_t

  xcb_randr_get_screen_info_reply_t

  xcb_randr_set_screen_size_request_t

  How do we handle window moves from one screen to another. Should we
  snap to the physical screen's edge and then allow move to continue?

  An idea from Christian: Use a huge virtual screen and make physical
  screens map to it. Perhaps we can actually manage to have a window
  on two physical screens at once?

* Key to move pointer to another physical screen.

* Use xcb-event's event handlers?

* Configurable keys.

* Configuration file.

* Start configurable programs when clicking on root window.

* Handle Urgency hint

  Some windows might need attention and marks this with an urgency
  hint (for instance, urxvt can generate such a hint when receiving
  the BEL character). Do we want to handle it? How do we tell the
  user? Can this be done with some stand-alone program instead?

* Support sensible portions of ICCCM and EWMH

  EWMH hints that tells applications about active workspace and
  focused window...

  And a few others.

* Use bitfields instead of extra lists for virtual screens?

* Dispatch table for key bindings instead of keysym->enum->case?
